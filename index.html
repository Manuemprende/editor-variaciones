<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Editor de Singularidad para ADS</title>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<style>
  :root{ --bg1:#0a0f1a; --bg2:#0b1320; --card:#0e1626; --stroke:#1c2740; --fg:#e9f0ff; --muted:#a9b8d6; --primary:#3b82f6; }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--fg);
    background:radial-gradient(1200px 800px at 15% 10%, rgba(59,130,246,.08), transparent 60%), linear-gradient(180deg,var(--bg1),var(--bg2));
    min-height:100vh; display:flex; align-items:center; justify-content:center; padding:34px;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; text-rendering:optimizeLegibility;
  }
  .app{width:100%; max-width:1100px; background:var(--card); border:1px solid var(--stroke);
       border-radius:20px; padding:26px; box-shadow:0 10px 40px rgba(0,0,0,.35)}
  .header{display:flex; flex-direction:column; align-items:center; gap:6px; margin-bottom:10px}
  h1{margin:0; font-size:28px; font-weight:800; letter-spacing:.1px; color:#e9f0ff; text-align:center}
  .sub{color:var(--muted); font-size:14px; text-align:center}
  .desc{margin-top:8px; color:#b8c6e8; font-size:13.5px; text-align:center}
  .grid{display:grid; grid-template-columns:1.1fr .9fr; gap:24px; margin-top:12px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} }

  .drop,.drop-mini{border:2px dashed var(--stroke); border-radius:14px; display:flex; align-items:center; justify-content:center; text-align:center; background:#0a1324; cursor:pointer; transition:.15s ease}
  .drop{min-height:200px; padding:22px; margin-bottom:12px}
  .drop-mini{min-height:84px; padding:12px}
  .drop:hover,.drop-mini:hover{border-color:#2a3a64}
  .drop.dragover,.drop-mini.dragover{border-color:var(--primary)}
  .hidden{display:none!important}

  .preview{
    position:relative;
    border:1px solid var(--stroke); border-radius:12px; background:#0b1426; padding:18px;
    min-height:320px; display:flex; align-items:center; justify-content:center; overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.02), 0 6px 24px rgba(0,0,0,.35);
  }
  video, canvas{
    max-width:100%; max-height:520px; border-radius:10px;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: -moz-crisp-edges;
  }
  .overlay-guide{ position:absolute; inset:0; pointer-events:none; }

  .field{background:#0b162e; border:1px solid #21345e; padding:14px 12px; border-radius:12px; color:var(--fg);
         display:flex; align-items:center; gap:12px; justify-content:space-between; margin-bottom:14px}
  .btn{appearance:none; border:1px solid #203055; background:#101a32; color:#fff; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:700; font-size:14px}
  .btn:hover{border-color:#2a3b6b; background:#0e1830}
  .btn.primaria{background:var(--primary); border-color:#2e6fe0; color:#0b1220}
  .help{font-size:12.5px; color:#a9b8d6}
  .filename{font-size:12.5px; color:#9fb7ff}
  .progress{height:10px; background:#0a1428; border:1px solid #1c2f55; border-radius:999px; overflow:hidden; margin-top:18px}
  .bar{height:100%; width:0%; background:linear-gradient(90deg, var(--primary), #67a5ff); transition:width .2s ease}
  .toolbar{display:flex; gap:12px; flex-wrap:wrap; margin-top:14px}
  input[type="text"], input[type="number"], select{
    background:#0b162e; border:1px solid #21345e; color:#e9f0ff; padding:10px 12px; border-radius:10px; outline:none
  }
</style>
</head>
<body>
<div class="app" id="app">
  <div class="header">
    <h1>Editor de Singularidad para ADS</h1>
    <div class="sub">Base intacta. <b>bordes sutiles</b> (color distinto o multicolor), <b>figuras/franjas casi invisibles</b>, <b>marca de agua centrada</b> y <b>espejo</b>.</div>
    <div class="desc">Herramienta para generar hasta 10 variaciones de una imagen (o 1 de video) con micro-detalles sutiles que reducen la singularidad en campa√±as. Todo se procesa en tu navegador y se descarga en un .zip.</div>
  </div>

  <div class="grid">
    <!-- IZQ -->
    <div>
      <label id="drop" class="drop" for="file">
        <div>
          <div style="font-weight:800; font-size:16px; margin-bottom:6px">Suelta tu imagen/video aqu√≠ o haz clic</div>
          <div class="help">JPG/PNG/GIF/WEBP o MP4 (‚â§ 15MB)</div>
        </div>
        <input id="file" class="hidden" type="file" accept="image/png,image/jpeg,image/gif,image/webp,video/mp4"/>
      </label>

      <div id="fileInfo" class="field hidden" style="justify-content:flex-start; gap:14px">
        <span id="fileName" class="filename"></span>
        <button id="changeBtn" class="btn" type="button">Cambiar archivo</button>
      </div>

      <div id="preview" class="preview"><div class="help">Tu vista previa aparecer√° aqu√≠</div></div>

      <div class="toolbar">
        <button id="mirrorBtn" class="btn" disabled type="button">Espejo ‚Üî</button>
        <button id="clearBtn" class="btn" disabled type="button">Limpiar</button>
      </div>
    </div>

    <!-- DER -->
    <div>
      <div class="field">
        <label for="count"><b>Variaciones</b></label>
        <input id="count" type="number" min="1" max="10" value="6" style="width:72px;text-align:center"/>
      </div>

      <div id="countHelp" class="help" style="margin:-8px 0 10px 2px; display:none">
        Para <b>video</b> se descarga <b>solo 1 variaci√≥n</b> (estabilidad/calidad).
      </div>

      <div class="field">
        <label for="zipname"><b>Nombre del ZIP</b></label>
        <input id="zipname" type="text" placeholder="mi_campa√±a_ads" value="variaciones_ads"/>
      </div>

      <div class="field">
        <label for="seed"><b>Semilla</b></label>
        <div style="display:flex;gap:8px;align-items:center;width:100%">
          <input id="seed" type="text" placeholder="vac√≠o = aleatoria" style="flex:1"/>
          <button id="seedRnd" class="btn" type="button" title="Generar semilla aleatoria">üé≤</button>
        </div>
      </div>
      <div class="help" id="seedHelp">
        Usa una palabra/clave para reproducir exactamente las variaciones. Si lo dejas vac√≠o, ser√° distinta cada vez.
      </div>

      <!-- Duraci√≥n y formato (video) -->
      <div class="field" id="videoOpts" style="flex-direction:column; align-items:flex-start; display:none">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap">
          <b>Duraci√≥n</b>
          <label style="display:flex;align-items:center;gap:6px"><input type="radio" name="dur" id="durFull" checked/> Completa</label>
          <label style="display:flex;align-items:center;gap:6px"><input type="radio" name="dur" id="durClip"/> Recortar a
            <input id="sec" type="number" min="3" max="120" value="12" style="width:70px; margin-left:6px; text-align:center"/> s
          </label>
        </div>
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-top:8px">
          <b>Formato</b>
          <select id="format">
            <option value="video/mp4;codecs=h264">MP4 H.264 (beta)</option>
            <option value="video/webm;codecs=vp9">WebM VP9</option>
          </select>
          <span id="formatNote" class="help"></span>
        </div>
        <!-- NUEVO: Exportar ambos -->
        <div style="display:flex; gap:12px; align-items:center; margin-top:8px">
          <label style="display:flex;align-items:center;gap:8px">
            <input id="bothFormats" type="checkbox"/> <b>Exportar ambos formatos (MP4 + WebM)</b>
          </label>
        </div>
        <div id="bothNote" class="help" style="margin-top:6px"></div>
      </div>

      <div class="field" style="flex-direction:column; align-items:flex-start">
        <label style="display:flex;gap:10px;align-items:center"><input id="optBorder" type="checkbox" checked/> <b>Borde color sutil</b></label>
        <label style="display:flex;gap:10px;align-items:center"><input id="optBorderMulti" type="checkbox"/> <b>Borde multicolor sutil</b></label>
        <label style="display:flex;gap:10px;align-items:center"><input id="optShapes" type="checkbox" checked/> <b>Figuras casi invisibles</b></label>
        <label style="display:flex;gap:10px;align-items:center"><input id="optStripes" type="checkbox" checked/> <b>Franjas casi invisibles</b></label>
        <label style="display:flex;gap:10px;align-items:center"><input id="optCenterWM" type="checkbox" checked/> <b>Marca de agua centrada</b></label>
      </div>

      <!-- Modo inspecci√≥n (solo visual) -->
      <div class="field" style="flex-direction:column; align-items:flex-start">
        <label style="display:flex;gap:10px;align-items:center">
          <input id="optInspect" type="checkbox"/> <b>Inspecci√≥n (solo visual)</b>
        </label>
        <span class="help">Muestra gu√≠as en la vista previa; no se exportan. Para coincidencia exacta con la descarga, fija una Semilla.</span>
      </div>

      <div class="field" style="flex-direction:column;align-items:flex-start">
        <div class="help" style="margin-bottom:8px">Logo para marca de agua (no reemplaza la imagen/video)</div>
        <label id="dropLogo" class="drop-mini">
          <div><b>Arrastra tu logo</b> (PNG/JPG) o haz clic</div>
          <input id="logoFile" class="hidden" type="file" accept="image/png,image/jpeg"/>
        </label>
        <div id="logoInfo" class="filename hidden"></div>
        <div style="display:flex;gap:8px;margin-top:6px">
          <button id="clearLogo" class="btn" type="button">Quitar logo</button>
        </div>
      </div>

      <div class="help">Salida im√°genes: PNG. Salida video: MP4 o WebM (seg√∫n soporte). Todo 100% en tu navegador.</div>

      <div class="progress"><div id="bar" class="bar"></div></div>
      <div style="display:flex;gap:12px;justify-content:flex-end;margin-top:14px">
        <button id="cancelBtn" class="btn" type="button" disabled>Cancelar</button>
        <button id="downloadBtn" class="btn primaria" disabled type="button">Descargar variaciones (.zip)</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const els = {
    drop: $('drop'), fileInput: $('file'), fileInfo: $('fileInfo'), fileName: $('fileName'),
    changeBtn: $('changeBtn'), preview: $('preview'),
    mirrorBtn: $('mirrorBtn'), clearBtn: $('clearBtn'),
    count: $('count'), countHelp: $('countHelp'), downloadBtn: $('downloadBtn'), cancelBtn: $('cancelBtn'), bar: $('bar'),
    optBorder: $('optBorder'), optBorderMulti: $('optBorderMulti'), optShapes: $('optShapes'), optStripes: $('optStripes'), optCenterWM: $('optCenterWM'),
    optInspect: $('optInspect'),
    logoDrop: $('dropLogo'), logoFile: $('logoFile'), logoInfo: $('logoInfo'), clearLogo: $('clearLogo'),
    zipname: $('zipname'), videoOpts: $('videoOpts'),
    durFull: $('durFull'), durClip: $('durClip'), sec: $('sec'), format: $('format'), formatNote: $('formatNote'),
    bothFormats: $('bothFormats'), bothNote: $('bothNote'),
    seed: $('seed'), seedRnd: $('seedRnd'), seedHelp: $('seedHelp')
  };

  const MAX_VIDEO = 15 * 1024 * 1024;
  const state = { file:null, kind:null, objectURL:null, logo:null, baseHue:null, mirror:false, abort:false, previewSeed:null, overlayCanvas:null };

  const CFG = {
    watermarkOpacity: [0.01, 0.02],
    shapeAlpha:       [0.006, 0.012],
    /* AUMENTADO sutilmente (antes 0.008‚Äì0.018) */
    shapeSize:        [0.012, 0.026],
    borderWidth:      [0.004, 0.007],
    borderAlpha:      0.20,
    stripeAlpha:      [0.006, 0.014],
    stripeWidth:      [0.006, 0.012],
    stripeGapMul:     [3.5, 5.5],
    stripeAngle:      [-30, 30]
  };

  // --- Formato: soporte y fallback
  function isSupported(mime){ try{ return MediaRecorder.isTypeSupported(mime); }catch{ return false; } }
  function updateFormatNote(){
    const sel = els.format.value;
    const ok  = isSupported(sel);
    const mp4Ok = isSupported('video/mp4;codecs=h264');
    const webmOk = isSupported('video/webm;codecs=vp9') || isSupported('video/webm;codecs=vp8') || isSupported('video/webm');
    if (ok) els.formatNote.textContent = sel.includes('mp4') ? 'MP4 disponible en este navegador.' : 'WebM disponible en este navegador.';
    else {
      const alt = sel.includes('mp4') ? (webmOk ? 'WebM' : 'no disponible') : (mp4Ok ? 'MP4' : 'no disponible');
      els.formatNote.textContent = alt==='no disponible'
        ? 'Este navegador no soporta el formato seleccionado ni su alternativa.'
        : `Este navegador no soporta el formato seleccionado. Se usar√° ${alt}.`;
    }
    // ayuda para "ambos formatos"
    const msg = [];
    if (!mp4Ok) msg.push('MP4 no soportado aqu√≠');
    if (!webmOk) msg.push('WebM no soportado aqu√≠');
    els.bothNote.textContent = msg.length ? ('Nota: ' + msg.join(' ¬∑ ')) : 'Se generar√°n ambos si est√°n soportados.';
  }
  function getBestMime(selected){
    if (isSupported(selected)) return { mime:selected, fallback:false, to:null };
    const alt = selected.includes('mp4')
      ? (isSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
         isSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' :
         isSupported('video/webm') ? 'video/webm' : '')
      : (isSupported('video/mp4;codecs=h264') ? 'video/mp4;codecs=h264' : '');
    return { mime: alt, fallback: !!alt, to: alt || null };
  }

  // Dropzones
  setupDrop(els.drop);
  els.fileInput.addEventListener('change', e => { const f=e.target.files?.[0]; if(f) handleMainFile(f); });
  els.changeBtn.addEventListener('click', () => els.fileInput.click());
  els.clearBtn.addEventListener('click', clearAll);
  els.mirrorBtn.addEventListener('click', () => { if(!state.file) return; state.mirror = !state.mirror; els.mirrorBtn.textContent = state.mirror ? 'Espejo ACTIVADO ‚Üî' : 'Espejo ‚Üî'; renderPreview(); });
  els.cancelBtn.addEventListener('click', () => { state.abort = true; });
  els.seedRnd.addEventListener('click', () => { els.seed.value = genReadableSeed(); });
  els.format.addEventListener('change', updateFormatNote);
  ['optBorder','optBorderMulti','optShapes','optStripes','optCenterWM','optInspect','seed'].forEach(id=>{
    $(id).addEventListener('change', () => renderPreview());
  });

  setupMiniDrop(els.logoDrop, f => handleLogoFile(f));
  els.logoFile.addEventListener('change', e => { const f=e.target.files?.[0]; if(f) handleLogoFile(f); });
  els.clearLogo.addEventListener('click', () => { state.logo=null; els.logoInfo.classList.add('hidden'); els.logoFile.value=''; renderPreview(); });

  // logo por defecto si existe (opcional)
  fetch('assets/logo.png').then(r => r.ok ? r.blob() : null).then(b => {
    if (!b) return;
    const u = URL.createObjectURL(b); const img = new Image();
    img.onload = () => { state.logo = img; URL.revokeObjectURL(u); showLogoInfo('(assets/logo.png)'); };
    img.src = u;
  }).catch(()=>{});

  // set nota inicial de formato
  updateFormatNote();

  // Atajo teclado: I = toggle inspecci√≥n
  window.addEventListener('keydown', (e) => {
    if (e.key && e.key.toLowerCase()==='i' && state.file){
      els.optInspect.checked = !els.optInspect.checked;
      renderPreview();
    }
  });

  function setupDrop(el){
    ['dragenter','dragover'].forEach(ev => el.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); el.classList.add('dragover'); }));
    ['dragleave','drop'].forEach(ev => el.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); el.classList.remove('dragover'); }));
    el.addEventListener('drop', e => { const f=e.dataTransfer.files?.[0]; if(f) handleMainFile(f); });
  }
  function setupMiniDrop(el, onFile){
    ['dragenter','dragover'].forEach(ev => el.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); el.classList.add('dragover'); }));
    ['dragleave','drop'].forEach(ev => el.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); el.classList.remove('dragover'); }));
    el.addEventListener('drop', e => { const f=e.dataTransfer.files?.[0]; if(f) onFile(f); });
  }

  function handleLogoFile(file){
    if(!/^image\/(png|jpeg)$/.test(file.type)) return alert('Logo: PNG o JPG.');
    const u=URL.createObjectURL(file); const img=new Image();
    img.onload=()=>{ state.logo=img; URL.revokeObjectURL(u); showLogoInfo(file.name); renderPreview(); };
    img.src=u;
  }
  function showLogoInfo(name){ els.logoInfo.textContent='Logo cargado: '+name; els.logoInfo.classList.remove('hidden'); }

  // Carga principal
  async function handleMainFile(file){
    const isImage = /^image\/(png|jpeg|gif|webp)$/.test(file.type);
    const isVideo = file.type === 'video/mp4';
    if(!(isImage||isVideo)) return alert('Formato no soportado.');
    if(isVideo && file.size > MAX_VIDEO) return alert('Video > 15MB.');

    state.file=file; state.kind=isImage?'image':'video';
    if(state.objectURL) URL.revokeObjectURL(state.objectURL);
    state.objectURL=URL.createObjectURL(file);
    $('fileName').textContent=file.name+' ‚Ä¢ '+Math.round(file.size/1024)+' KB';
    $('fileInfo').classList.remove('hidden'); $('drop').classList.add('hidden');
    state.previewSeed = genReadableSeed(); // semilla para inspecci√≥n si no hay Semilla fija
    setEnabled(true); renderPreview();

    // UI para video
    if (state.kind==='video'){ els.count.value=1; els.count.disabled=true; els.countHelp.style.display='block'; els.videoOpts.style.display='flex'; }
    else { els.count.disabled=false; els.countHelp.style.display='none'; els.videoOpts.style.display='none'; }

    try{
      state.baseHue = state.kind==='image'
        ? await estimateHueFromImageURL(state.objectURL)
        : await estimateHueFromVideoURL(state.objectURL);
    }catch(e){ state.baseHue = null; }
  }

  function renderPreview(){
    $('preview').innerHTML='';
    if(state.kind==='image'){
      const img=new Image();
      img.onload=()=>{
        const c=document.createElement('canvas'), ctx=c.getContext('2d',{desynchronized:true});
        const {width,height}=fitWithin(img.width,img.height,960,540);
        const dpr=window.devicePixelRatio||1;
        c.width=Math.round(width*dpr); c.height=Math.round(height*dpr);
        c.style.width=width+'px'; c.style.height=height+'px';
        ctx.scale(dpr,dpr); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';

        ctx.save();
        if (state.mirror){ ctx.translate(width,0); ctx.scale(-1,1); }
        ctx.drawImage(img,0,0,width,height);
        ctx.restore();

        // Inspecci√≥n (gu√≠as SOLO en preview)
        if (els.optInspect.checked){
          const seedStr = (els.seed.value||'').trim() || state.previewSeed;
          const R = makeRandomizers(seedStr);
          drawGuideOverlay(ctx, width, height, R);
        }

        $('preview').appendChild(c);
      };
      img.src=state.objectURL;
    }else{
      const wrap = document.createElement('div');
      wrap.style.position='relative'; wrap.style.display='inline-block';
      const v=document.createElement('video'); v.src=state.objectURL; v.controls=true; v.muted=true; v.playsInline=true;
      v.style.filter='contrast(1.01) saturate(1.01)';
      v.style.transform = state.mirror ? 'scaleX(-1)' : 'none';
      wrap.appendChild(v);
      $('preview').appendChild(wrap);

      const renderOverlay = () => {
        if (state.overlayCanvas && state.overlayCanvas.parentNode) state.overlayCanvas.parentNode.removeChild(state.overlayCanvas);
        if (!els.optInspect.checked) return;

        const rect = v.getBoundingClientRect();
        const cw = Math.max(1, Math.round(rect.width));
        const ch = Math.max(1, Math.round(rect.height));

        const oc = document.createElement('canvas');
        oc.width=cw; oc.height=ch; oc.className='overlay-guide';
        oc.style.width=cw+'px'; oc.style.height=ch+'px';
        const octx=oc.getContext('2d');
        octx.imageSmoothingEnabled=true; octx.imageSmoothingQuality='high';

        const seedStr = (els.seed.value||'').trim() || state.previewSeed;
        const R = makeRandomizers(seedStr);

        drawGuideOverlay(octx, cw, ch, R);

        wrap.appendChild(oc);
        state.overlayCanvas = oc;
      };

      v.addEventListener('loadedmetadata', renderOverlay);
      new ResizeObserver(()=>renderOverlay()).observe(wrap);
      if (els.optInspect.checked) {
        if (v.readyState>=1) renderOverlay();
      }
    }
  }

  function drawGuideOverlay(ctx,w,h,R){
    if (els.optBorder.checked){
      paintSoftBorderGuide(ctx,w,h);
      if (els.optBorderMulti.checked) paintSoftBorderMultiGuide(ctx,w,h);
    }
    if (els.optShapes.checked)  paintTinyShapesGuide(ctx,w,h,R);
    if (els.optStripes.checked) paintInvisibleStripesGuide(ctx,w,h,R);
    if (els.optCenterWM.checked) paintCenteredLogoGuide(ctx,w,h,R);
  }

  function setEnabled(v){
    els.downloadBtn.disabled = !v;
    els.clearBtn.disabled    = !v;
    els.mirrorBtn.disabled   = !v;
  }

  function fitWithin(w,h,maxW,maxH){ const r=Math.min(maxW/w, maxH/h, 1); return {width:Math.round(w*r), height:Math.round(h*r)}; }
  function clearAll(){
    if(state.objectURL) URL.revokeObjectURL(state.objectURL);
    state.file=null; state.kind=null; state.objectURL=null; state.baseHue=null; state.mirror=false; state.abort=false; state.previewSeed=null;
    $('preview').innerHTML='<div class="help">Tu vista previa aparecer√° aqu√≠</div>';
    els.mirrorBtn.textContent='Espejo ‚Üî';
    $('file').value=''; setEnabled(false);
    $('fileInfo').classList.add('hidden'); $('drop').classList.remove('hidden');
    els.count.disabled=false; els.countHelp.style.display='none'; els.videoOpts.style.display='none';
  }

  // --------- RNG determinista (semilla)
  function hash32(str){
    let h=2166136261>>>0;
    for (let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h*16777619)>>>0; }
    return h>>>0;
  }
  function mulberry32(a){ return function(){ a|=0; a=a+0x6D2B79F5|0; let t=Math.imul(a^a>>>15,1|a); t=t+Math.imul(t^t>>>7,61|t)^t; return ((t^t>>>14)>>>0)/4294967296; } }
  function makeRNG(seedStr){ if (!seedStr) return Math.random; const s=hash32(seedStr); const r=mulberry32(s); return ()=>r(); }
  function makeRandomizers(seedStr){
    const rng = makeRNG(seedStr);
    return { rng, rnd:(a,b)=>rng()*(b-a)+a, rndInt:(a,b)=>Math.floor(rng()*(b-a+1))+a, randRange:([a,b])=>rng()*(b-a)+a };
  }
  function genReadableSeed(){
    const d = new Date();
    const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
    const rand = Math.random().toString(16).slice(2,6);
    return `ads-${y}${m}${day}-${rand}`;
  }

  const wrap360=h=>((h%360)+360)%360;
  const withAlpha=(hsl,a)=>hsl.replace('hsl','hsla').replace(')',`, ${a})`);
  const GOLDEN = 137.508;

  function borderColorFor(idx, baseHue, R){
    let h = wrap360((baseHue ?? 200) + 180 + idx*GOLDEN);
    if (baseHue!=null){
      const d = Math.min(Math.abs(h-baseHue), 360-Math.abs(h-baseHue));
      if (d < 40) h = wrap360(h + 60);
    }
    const s = 62 + (R?.rng?.()||Math.random())*6, l = 60 + (R?.rng?.()||Math.random())*6;
    return `hsl(${h}, ${s}%, ${l}%)`;
  }

  function rgb2hsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h,s,l=(max+min)/2;
    if(max===min){ h=0; s=0; }
    else{
      const d=max-min; s=l>0.5? d/(2-max-min) : d/(max+min);
      switch(max){ case r:h=(g-b)/d+(g<b?6:0); break; case g:h=(b-r)/d+2; break; case b:h=(r-g)/d+4; }
      h*=60;
    }
    return [h,s,l];
  }
  async function estimateHueFromImageURL(url){
    const img = await new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=url; });
    const w=64, h=64; const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.drawImage(img,0,0,w,h); const {data}=ctx.getImageData(0,0,w,h);
    let sx=0, sy=0;
    for(let i=0;i<data.length;i+=16){
      const [h,s]=rgb2hsl(data[i],data[i+1],data[i+2]); const rad=h*Math.PI/180; sx+=Math.cos(rad)*s; sy+=Math.sin(rad)*s;
    }
    return wrap360(Math.atan2(sy,sx)*180/Math.PI);
  }
  async function estimateHueFromVideoURL(url){
    const v=document.createElement('video'); v.src=url; v.muted=true; v.playsInline=true;
    await new Promise((res,rej)=>{ v.onloadeddata=res; v.onerror=rej; });
    try{ v.currentTime=Math.min(0.2, v.duration||0); }catch{}
    await new Promise((res)=>{ v.onseeked=res; v.onloadeddata && res(); });
    const c=document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d'); ctx.drawImage(v,0,0,64,64);
    const {data}=ctx.getImageData(0,0,64,64);
    let sx=0, sy=0;
    for(let i=0;i<data.length;i+=16){
      const [h,s]=rgb2hsl(data[i],data[i+1],data[i+2]); const rad=h*Math.PI/180; sx+=Math.cos(rad)*s; sy+=Math.sin(rad)*s;
    }
    return wrap360(Math.atan2(sy,sx)*180/Math.PI);
  }

  // --------- Descarga
  $('downloadBtn').addEventListener('click', async () => {
    if (!state.file) return;

    // Airbag: desactivar inspecci√≥n durante export (y recordar estado)
    const wasInspectOn = els.optInspect.checked;
    if (wasInspectOn) { els.optInspect.checked = false; renderPreview(); }

    const seedUI = (els.seed.value||'').trim();
    const seedBase = seedUI || genReadableSeed();

    state.abort = false;
    els.cancelBtn.disabled = false;

    let count = clamp(parseInt($('count').value||'1',10),1,10);
    if (state.kind==='video') count = 1; // s√≥lo 1 variaci√≥n por video (pero puede salir MP4+WebM)
    const base = sanitizeName($('zipname').value);
    setProgress(0); $('downloadBtn').disabled=true;

    try{
      const zip = new JSZip();

      if (state.kind === 'image'){
        const R = makeRandomizers(seedBase);
        const img = await blobToImage(state.file);
        const baseHue = state.baseHue ?? await estimateHueFromImageURL(state.objectURL);
        for (let i=1;i<=count;i++){
          if (state.abort) break;
          const out = await renderImageVariation(img,{
            border: els.optBorder.checked, borderMulti: els.optBorderMulti.checked,
            shapes: els.optShapes.checked, stripes: els.optStripes.checked, centerWM: els.optCenterWM.checked
          }, { index:i, borderColor: borderColorFor(i, baseHue, R) }, R);
          zip.file(`${base}_img_${i}.png`, out, {binary:true});
          setProgress(i*(100/count));
        }
      } else {
        // ---- VIDEO
        const info = await loadVideoMeta(state.objectURL);
        const baseHue = state.baseHue ?? await estimateHueFromVideoURL(state.objectURL);

        // Si "ambos formatos" est√° activo, preparamos dos salidas con semillas derivadas distintas
        const wantBoth = els.bothFormats.checked;
        const targets = [];

        const mp4Mime = 'video/mp4;codecs=h264';
        const webmMime = isSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
                        : isSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8'
                        : (isSupported('video/webm') ? 'video/webm' : '');

        if (wantBoth) {
          if (isSupported(mp4Mime)) targets.push({label:'mp4', mime:mp4Mime, seedSuffix:'|mp4'});
          if (webmMime)            targets.push({label:'webm', mime:webmMime, seedSuffix:'|webm'});
          if (!targets.length) throw new Error('Este navegador no puede exportar ni MP4 ni WebM.');
        } else {
          const sel = els.format.value;
          const best = getBestMime(sel);
          if (!best.mime) throw new Error('Ning√∫n formato de video es soportado por este navegador.');
          const label = best.mime.includes('mp4') ? 'mp4' : 'webm';
          targets.push({label, mime:best.mime, seedSuffix:''}); // una sola salida
          if (best.fallback) els.formatNote.textContent = sel.includes('mp4') ? 'MP4 no soportado. Se exportar√° WebM.' : 'WebM no soportado. Se exportar√° MP4.';
          else updateFormatNote();
        }

        // Exportar cada objetivo con distinta singularidad usando semillas derivadas
        for (let idx=0; idx<targets.length; idx++){
          const t = targets[idx];
          const seed = seedBase + t.seedSuffix;   // <- distinta singularidad por formato
          const Rf = makeRandomizers(seed);

          const recCfg = {
            full: $('durFull').checked,
            maxSeconds: parseInt($('sec').value||'12',10),
            mime: t.mime,
            bps: 8_000_000,
            borderColor: borderColorFor(1, baseHue, Rf),
            onProgress: p => {
              if (targets.length===1) setProgress(p);
              else {
                const basePct = (idx/targets.length)*100;
                const spanPct = (1/targets.length)*100;
                setProgress(basePct + p*(spanPct/100));
              }
            }
          };

          const blob = await renderVideoVariation(state.objectURL,{
            border: els.optBorder.checked, borderMulti: els.optBorderMulti.checked,
            shapes: els.optShapes.checked, stripes: els.optStripes.checked, centerWM: els.optCenterWM.checked,
            mirror: state.mirror
          }, { width:info.width, height:info.height }, recCfg, Rf);

          if (state.abort) break;

          const ext = t.label; // 'mp4' o 'webm'
          zip.file(`${base}_video_1.${ext}`, blob, {binary:true});
        }
        if (!state.abort) setProgress(100);
      }

      // MANIFIESTO
      if (!state.abort){
        zip.file('manifest.json', JSON.stringify({
          app: "Editor de Singularidad para ADS",
          version: "v20",
          kind: state.kind,
          seed: seedUI || null,
          mirror: state.mirror,
          options: {
            border: els.optBorder.checked,
            borderMulti: els.optBorderMulti.checked,
            shapes: els.optShapes.checked,
            stripes: els.optStripes.checked,
            centerWM: els.optCenterWM.checked,
            inspect: els.optInspect.checked,
            bothFormats: state.kind==='video' ? els.bothFormats.checked : false
          },
          video: (state.kind==='video') ? {
            durationMode: els.durFull.checked ? 'full' : 'clip',
            clipSeconds: parseInt(els.sec.value||'12',10),
            formatRequested: els.format.value
          } : null,
          count: (state.kind==='video') ? 1 : parseInt(els.count.value||'1',10),
          timestamp: new Date().toISOString()
        }, null, 2));
      }

      if (!state.abort){
        const zipBlob = await zip.generateAsync({type:'blob'});
        downloadBlob(zipBlob, `${base}.zip`);
      }
    }catch(e){ console.error(e); alert('No se pudo generar la exportaci√≥n. Prueba con Chrome/Edge y mant√©n la pesta√±a activa.'); }
    finally{
      $('downloadBtn').disabled=false;
      els.cancelBtn.disabled = true;
      setTimeout(()=>setProgress(0),800);
      state.abort=false;

      // Restaurar inspecci√≥n si estaba activa
      if (typeof wasInspectOn !== 'undefined' && wasInspectOn) {
        els.optInspect.checked = true;
        renderPreview();
      }
    }
  });

  // --------- Utils
  function sanitizeName(str){
    const s=(str||'').toString().trim().toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .replace(/[^a-z0-9._-]+/g,'_').replace(/^_+|_+$/g,'');
    return s || 'variaciones_ads';
  }
  function setProgress(p){ els.bar.style.width = Math.max(0,Math.min(100,p)) + '%'; }
  function downloadBlob(blob, fn){ const a=document.createElement('a'); const u=URL.createObjectURL(blob); a.href=u; a.download=fn; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(u),1500); }
  function blobToImage(b){ return new Promise((res,rej)=>{ const u=URL.createObjectURL(b); const i=new Image(); i.onload=()=>{URL.revokeObjectURL(u);res(i)}; i.onerror=rej; i.src=u; }); }
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  // --------- Render IMAGEN
  async function renderImageVariation(img, opts, vctx, R){
    const maxSide=2000, s=Math.min(1, maxSide/Math.max(img.width,img.height));
    const w=Math.round(img.width*s), h=Math.round(img.height*s);
    const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';

    ctx.save(); if (state.mirror){ ctx.translate(w,0); ctx.scale(-1,1); } ctx.drawImage(img,0,0,w,h); ctx.restore();

    if (opts.border){ if (opts.borderMulti) paintSoftBorderMulti(ctx,w,h,state.baseHue,R); else paintSoftBorder(ctx,w,h,vctx.borderColor,R); }
    if (opts.shapes)  paintTinyShapes(ctx,w,h,R);
    if (opts.stripes) paintInvisibleStripes(ctx,w,h,R);
    if (opts.centerWM) paintCenteredLogo(ctx,w,h,state.logo,R);

    return await new Promise(r=>c.toBlob(r,'image/png',0.95));
  }

  // --------- Overlays reales (export)
  function paintSoftBorder(ctx,w,h,color,R){
    const minSide=Math.min(w,h);
    const size=Math.max(1, Math.round(minSide*(R.randRange(CFG.borderWidth))));
    ctx.save(); ctx.lineWidth=size; ctx.strokeStyle=withAlpha(color, CFG.borderAlpha);
    ctx.strokeRect(size/2, size/2, w-size, h-size); ctx.restore();
  }
  function paintSoftBorderMulti(ctx,w,h,baseHue,R){
    const minSide=Math.min(w,h);
    const size=Math.max(1, Math.round(minSide*(0.004 + R.rng()*(0.007-0.004))));
    const hues = [0,90,180,270].map(d => wrap360((baseHue ?? 200) + d + 30*R.rng()));
    const cols = hues.map(h => `hsla(${h}, ${60+8*R.rng()}%, ${62+8*R.rng()}%, 0.18)`);
    ctx.save(); ctx.lineWidth=size;
    ctx.strokeStyle=cols[0]; ctx.beginPath(); ctx.moveTo(size/2, size/2); ctx.lineTo(w-size/2, size/2); ctx.stroke();
    ctx.strokeStyle=cols[1]; ctx.beginPath(); ctx.moveTo(w-size/2, size/2); ctx.lineTo(w-size/2, h-size/2); ctx.stroke();
    ctx.strokeStyle=cols[2]; ctx.beginPath(); ctx.moveTo(w-size/2, h-size/2); ctx.lineTo(size/2, h-size/2); ctx.stroke();
    ctx.strokeStyle=cols[3]; ctx.beginPath(); ctx.moveTo(size/2, h-size/2); ctx.lineTo(size/2, size/2); ctx.stroke();
    ctx.restore();
  }
  function paintTinyShapes(ctx,w,h,R){
    /* AUMENTAMOS cantidad m√≠nima y m√°xima un poco (antes 2‚Äì4) */
    const minSide=Math.min(w,h), n=R.rndInt(3,5);
    for (let i=0;i<n;i++){
      ctx.save();
      const s=minSide*R.randRange(CFG.shapeSize);
      const x=R.rnd(s, w-s), y=R.rnd(s, h-s);
      ctx.translate(x,y); ctx.rotate((R.rng()*14-7)*Math.PI/180);
      ctx.globalAlpha=R.randRange(CFG.shapeAlpha);
      ctx.fillStyle=`hsl(${Math.floor(R.rng()*360)},60%,65%)`;
      const t=R.rng();
      if (t<0.34){ ctx.beginPath(); ctx.arc(0,0,s*0.4,0,Math.PI*2); ctx.fill(); }
      else if (t<0.67){ roundedRect(ctx,-s*0.45,-s*0.25,s*0.9,s*0.5,s*0.12); ctx.fill(); }
      else { ctx.beginPath(); ctx.moveTo(-s*0.35,s*0.35); ctx.lineTo(0,-s*0.35); ctx.lineTo(s*0.35,s*0.35); ctx.closePath(); ctx.fill(); }
      ctx.restore();
    }
  }
  function roundedRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function paintInvisibleStripes(ctx,w,h,R){
    const minSide=Math.min(w,h);
    const angle = R.randRange(CFG.stripeAngle) * Math.PI/180;
    const stripeW = minSide * R.randRange(CFG.stripeWidth);
    const gap    = stripeW * R.randRange(CFG.stripeGapMul);
    const len    = Math.sqrt(w*w + h*h) + stripeW*2;
    const color  = withAlpha(`hsl(${Math.floor(R.rng()*360)},60%,65%)`, R.randRange(CFG.stripeAlpha));
    ctx.save(); ctx.translate(w/2, h/2); ctx.rotate(angle); ctx.globalCompositeOperation='soft-light'; ctx.fillStyle=color;
    for (let x=-len; x<=len; x+=gap) ctx.fillRect(x, -len, stripeW, len*2);
    ctx.restore();
  }
  function paintCenteredLogo(ctx,w,h,logo,R){
    if (!logo) return;
    const alpha=R.randRange(CFG.watermarkOpacity);
    ctx.save();
    const maxSide=Math.min(w,h)*0.28;
    const r=Math.min(maxSide/Math.max(logo.width,logo.height),1);
    const lw=logo.width*r, lh=logo.height*r;
    ctx.globalAlpha=alpha;
    ctx.drawImage(logo, Math.round((w-lw)/2), Math.round((h-lh)/2), Math.round(lw), Math.round(lh));
    ctx.restore();
  }

  // --------- GU√çAS (solo preview)
  function paintSoftBorderGuide(ctx,w,h){
    const size = Math.max(1, Math.round(Math.min(w,h)*0.006));
    ctx.save(); ctx.lineWidth=size; ctx.strokeStyle='rgba(255,255,0,0.65)'; ctx.setLineDash([8,6]);
    ctx.strokeRect(size/2, size/2, w-size, h-size); ctx.restore();
  }
  function paintSoftBorderMultiGuide(ctx,w,h){
    const size = Math.max(1, Math.round(Math.min(w,h)*0.006));
    const cols=['rgba(255,80,80,0.8)','rgba(80,200,255,0.8)','rgba(120,255,120,0.8)','rgba(255,220,120,0.8)'];
    ctx.save(); ctx.lineWidth=size; ctx.setLineDash([10,5]);
    ctx.strokeStyle=cols[0]; ctx.beginPath(); ctx.moveTo(size/2, size/2); ctx.lineTo(w-size/2, size/2); ctx.stroke();
    ctx.strokeStyle=cols[1]; ctx.beginPath(); ctx.moveTo(w-size/2, size/2); ctx.lineTo(w-size/2, h-size/2); ctx.stroke();
    ctx.strokeStyle=cols[2]; ctx.beginPath(); ctx.moveTo(w-size/2, h-size/2); ctx.lineTo(size/2, h-size/2); ctx.stroke();
    ctx.strokeStyle=cols[3]; ctx.beginPath(); ctx.moveTo(size/2, h-size/2); ctx.lineTo(size/2, size/2); ctx.stroke();
    ctx.restore();
  }
  function paintTinyShapesGuide(ctx,w,h,R){
    const minSide=Math.min(w,h), n=R.rndInt(3,5); /* gu√≠a acompasa export */
    for (let i=0;i<n;i++){
      ctx.save();
      const s=minSide*R.randRange(CFG.shapeSize);
      const x=R.rnd(s, w-s), y=R.rnd(s, h-s);
      ctx.translate(x,y); ctx.rotate((R.rng()*14-7)*Math.PI/180);
      ctx.globalAlpha=0.28;
      ctx.fillStyle='rgba(0,255,255,0.18)';
      ctx.strokeStyle='rgba(0,255,255,0.85)'; ctx.lineWidth=Math.max(1, s*0.03);
      const t=R.rng();
      if (t<0.34){ ctx.beginPath(); ctx.arc(0,0,s*0.4,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
      else if (t<0.67){ roundedRect(ctx,-s*0.45,-s*0.25,s*0.9,s*0.5,s*0.12); ctx.fill(); ctx.stroke(); }
      else { ctx.beginPath(); ctx.moveTo(-s*0.35,s*0.35); ctx.lineTo(0,-s*0.35); ctx.lineTo(s*0.35,s*0.35); ctx.closePath(); ctx.fill(); ctx.stroke(); }
      ctx.restore();
    }
  }
  function paintInvisibleStripesGuide(ctx,w,h,R){
    const minSide=Math.min(w,h);
    const angle = R.randRange(CFG.stripeAngle) * Math.PI/180;
    const stripeW = minSide * ( (CFG.stripeWidth[0]+CFG.stripeWidth[1])/2 );
    const gap    = stripeW * ( (CFG.stripeGapMul[0]+CFG.stripeGapMul[1])/2 );
    const len    = Math.sqrt(w*w + h*h) + stripeW*2;
    ctx.save(); ctx.translate(w/2, h/2); ctx.rotate(angle);
    ctx.fillStyle='rgba(255,0,200,0.15)';
    for (let x=-len; x<=len; x+=gap) ctx.fillRect(x, -len, stripeW, len*2);
    ctx.restore();
  }
  function paintCenteredLogoGuide(ctx,w,h,R){
    const maxSide=Math.min(w,h)*0.28;
    let lw = maxSide, lh = maxSide*0.6;
    if (state.logo){
      const r = Math.min(maxSide/Math.max(state.logo.width,state.logo.height),1);
      lw = state.logo.width*r; lh = state.logo.height*r;
    }
    const x = Math.round((w-lw)/2), y = Math.round((h-lh)/2);
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.setLineDash([6,4]); ctx.lineWidth=Math.max(1, Math.min(w,h)*0.004);
    ctx.strokeRect(x,y,lw,lh);
    ctx.restore();
  }

  // --------- Video helpers
  function loadVideoMeta(url){ return new Promise((res,rej)=>{ const v=document.createElement('video'); v.preload='metadata'; v.src=url; v.onloadedmetadata=()=>res({width:v.videoWidth,height:v.videoHeight,duration:v.duration}); v.onerror=rej; }); }

  async function renderVideoVariation(url,opts,meta,recCfg,R){
    const v=document.createElement('video'); v.src=url; v.muted=true; v.playsInline=true; v.crossOrigin='anonymous';
    await new Promise((res,rej)=>{ v.onloadedmetadata=res; v.onerror=rej; });

    const w=meta.width, h=meta.height, fps=30;
    const canvas=document.createElement('canvas'); canvas.width=w; canvas.height=h;
    const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';

    const canvasStream=canvas.captureStream(fps);
    try {
      if (v.captureStream) {
        const vStream = v.captureStream();
        const aud = vStream.getAudioTracks();
        if (aud && aud.length) canvasStream.addTrack(aud[0]);
      }
    } catch(_) {}

    const chunks=[]; const rec=new MediaRecorder(canvasStream,{mimeType:recCfg.mime,videoBitsPerSecond:recCfg.bps||8_000_000});
    rec.ondataavailable=e=>{ if(e.data&&e.data.size) chunks.push(e.data); };

    const target = recCfg.full ? (isFinite(v.duration) ? v.duration : 600) : Math.max(3, recCfg.maxSeconds||12);

    const drawBase = () => {
      ctx.save(); if (opts.mirror){ ctx.translate(w,0); ctx.scale(-1,1); } ctx.drawImage(v,0,0,w,h); ctx.restore();
    };

    const drawOverlays = () => {
      if(opts.border){ if(opts.borderMulti) paintSoftBorderMulti(ctx,w,h,state.baseHue,R); else paintSoftBorder(ctx,w,h, recCfg.borderColor,R); }
      if(opts.shapes)  paintTinyShapes(ctx,w,h,R);
      if(opts.stripes) paintInvisibleStripes(ctx,w,h,R);
      if(opts.centerWM) paintCenteredLogo(ctx,w,h,state.logo,R);
    };

    return await new Promise(async(res,rej)=>{
      let raf;
      rec.onstop=()=>{ cancelAnimationFrame(raf); res(new Blob(chunks,{type:rec.mimeType})); };
      rec.onerror=e=>rej(e);

      v.currentTime=0;
      await v.play(); rec.start(200);

      (function loop(){
        if (state.abort){ try{ v.pause(); }catch{} if(rec.state!=='inactive') rec.stop(); return; }
        if(v.paused||v.ended) return;
        ctx.clearRect(0,0,w,h);
        drawBase();
        drawOverlays();
        const t = recCfg.full ? v.currentTime : Math.min(v.currentTime, target);
        const pct = Math.min(100, (t/target)*100);
        if (recCfg && typeof recCfg.onProgress === 'function') recCfg.onProgress(pct); else setProgress(pct);
        if (!recCfg.full && t >= target - 0.03){ v.pause(); rec.stop(); return; }
        raf=requestAnimationFrame(loop);
      })();

      v.onended=()=>{ if (rec.state!=='inactive'){ drawBase(); drawOverlays(); if (recCfg && typeof recCfg.onProgress === 'function') recCfg.onProgress(100); else setProgress(100); rec.stop(); } };
    });
  }

})();
</script>
</body>
</html>
